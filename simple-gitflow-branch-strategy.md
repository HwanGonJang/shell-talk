. # **Simple GitFlow Branching Strategy** (통합본)

본 문서는 `main`과 `develop` 브랜치를 중심으로 한 가볍고 효율적인 Git 전략을 정의합니다. 이 전략은 개인 프로젝트 또는 소규모 팀에서 \*\*GitHub 이슈와 PR(Pull Request)\*\*을 중심으로 체계적으로 작업을 관리하고, 안정적인 배포와 빠른 개발 속도의 균형을 맞추는 것을 목표로 합니다.

## 1. 핵심 브랜치

이 전략은 3가지 종류의 브랜치를 사용합니다.

  * **`main`** 🚀 (안정적인 릴리즈 브랜치)

      * **역할**: **언제든 배포 가능한** 안정화된 프로덕션 코드만 포함합니다.
      * **규칙**: 절대로 이 브랜치에 직접 커밋(Commit)하지 않습니다. 오직 `develop` 브랜치 또는 긴급한 `hotfix` 브랜치만 병합(Merge)합니다.

  * **`develop`** 🚧 (최신 개발 브랜치)

      * **역할**: **다음에 배포될 버전**의 코드를 통합하는 브랜치입니다. 모든 기능 개발(`feature`)이 완료되면 이 브랜치로 병합됩니다.
      * **규칙**: `main`과 마찬가지로, 이 브랜치에 직접 커밋하지 않습니다. `feature` 브랜치들을 PR을 통해 병합하는 용도로만 사용합니다.

  * **`feature/<기능-설명>`** 🧑‍💻 (개별 작업 브랜치)

      * **역할**: **모든 실제 개발 작업**(새 기능, 버그 수정, 리팩토링 등)이 이루어지는 브랜치입니다.
      * **규칙**:
        1.  항상 **`develop`** 브랜치에서 생성합니다.
        2.  작업이 완료되면 **`develop`** 브랜치로 \*\*Pull Request(PR)\*\*를 통해 병합합니다.
        3.  브랜치 이름은 `feature/login-api`, `bugfix/25-user-validation`처럼 명확하게 짓습니다. (이슈 번호를 포함하는 것을 권장)

  * **`hotfix/<버그-설명>`** 🚨 (개별 작업 브랜치)

      * **역할**: **프로덕션에서 발견된 버그 수정**이 이루어지는 브랜치입니다.
      * **규칙**:
        1.  항상 **`main`** 브랜치에서 생성합니다.
        2.  작업이 완료되면 **`main`** 브랜치로 \*\*Pull Request(PR)\*\*를 통해 병합합니다.
        3.  마찬가지로 **`develop`** 브랜치로 \*\*Pull Request(PR)\*\*를 통해 병합합니다.
        4.  브랜치 이름은 `hotfix/25-user-validation`처럼 명확하게 짓습니다.

-----

## 2. 이슈 및 PR 관리 전략

모든 작업 흐름은 GitHub의 이슈와 PR을 기반으로 합니다.

### **GitHub Issues (이슈)**

  * 모든 작업(기능 개발, 버그 수정)은 **GitHub Issue를 생성하는 것에서 시작**합니다.
  * 이슈는 작업의 명분과 토론의 장이 되며, 작업이 완료되면 이 이슈 번호를 커밋 메시지에 사용하여 작업을 연결합니다.

### **Pull Requests (PR)**

  * `feature` 브랜치에서 `develop`으로, 또는 `develop`에서 `main`으로 병합할 때는 **반드시 PR 사용을 원칙**으로 합니다.
  * PR은 코드 리뷰, CI/CD 파이프라인 연동, 그리고 병합 전략(Squash/Merge)을 선택하는 핵심 관문입니다.

### **PR/Issue 템플릿 활용 (권장)**

  * 일관된 이슈와 PR 관리를 위해 템플릿을 사용합니다.
  * 팀에서 이슈를 쉽게 파악할 수 있도록 제목, 작업 내용, 라벨, 참고 사항 등을 상세히 정리합니다.

-----

## 3. 기본 개발 워크플로우 (이슈 → PR)

새로운 기능(예: 'DM 기능', 이슈 번호 `#25`)을 개발하는 과정입니다.

### **1단계: Feature 브랜치 생성**

GitHub에서 `#25` 이슈를 확인한 후, `develop` 브랜치에서 작업을 시작합니다.

```bash
# 1. develop 브랜치로 이동
git checkout develop

# 2. develop 브랜치를 최신 상태로 업데이트
git pull origin develop

# 3. 'feature/25-add-dm' 이라는 새 브랜치를 생성하고 이동
git checkout -b feature/25-add-dm
```

### **2단계: 개발 및 커밋 (작업 커밋)**

`feature` 브랜치에서 자유롭게 코드를 작성하고 커밋합니다.

  * **중요:** 이 단계의 커밋은 나중에 \*\*Squash(압축)\*\*될 것이므로, 이슈 번호를 포함하지 않고 작업 내용을 편하게 기록합니다.

<!-- end list -->

```bash
# (코드 작업...)
git add .
git commit -m "WIP: DM 전송을 위한 웹소켓 핸들러 추가"

# (작업 반복...)
git commit -m "Refactor: DM 메시지 타입 정의 및 오타 수정"
```

### **3단계: Pull Request 생성**

기능 개발이 완료되면 원격 저장소에 푸시하고 `develop` 브랜치로 PR을 생성합니다.

```bash
# 1. 원격 저장소에 내 feature 브랜치를 푸시
git push origin feature/25-add-dm

# 2. GitHub으로 이동하여 `feature/25-add-dm` -> `develop`로 PR 생성
# 3. PR 템플릿에 맞춰 내용을 작성하고, 본문에 "Closes #25"를 입력하여 이슈를 연결합니다.
```

### **4단계: 코드 리뷰 및 병합 (Squash and Merge)**

코드 리뷰가 완료되면, `develop` 브랜치의 히스토리를 깔끔하게 유지하기 위해 **Squash and Merge** 전략을 사용합니다.

1.  GitHub PR 페이지에서 **[Squash and Merge]** 버튼을 선택합니다.
2.  여러 개의 지저분한 작업 커밋이 하나의 커밋으로 압축됩니다.
3.  **이때, 최종 커밋 메시지를 아래의 "커밋 메시지 컨벤션"에 맞게 수정합니다.**
      * *(예시)* `Feat: #25 DM 기능 구현`
4.  병합을 완료하면, `develop` 브랜치에는 이 깔끔한 커밋 하나만 남게 되며 연결된 `#25` 이슈는 자동으로 닫힙니다.

-----

## 4. 릴리즈 워크플로우 (배포)

`develop` 브랜치에 충분한 기능이 모여 안정화되었다고 판단되면, 프로덕션(`main`)에 배포합니다.

### **1단계: 릴리즈 PR 생성**

`develop`의 최신 내용을 `main`으로 병합하기 위한 PR을 생성합니다. (예: `Release v1.0.0`)

### **2단계: 병합 (Merge Commit)**

  * **중요:** 배포 시에는 `develop`에 쌓인 **모든 기능 커밋 내역(`Feat: #25...`, `Fix: #31...` 등)을 보존**해야 합니다.
  * 따라서 이때는 Squash가 아닌, \*\*일반 Merge Commit (`Create a merge commit`)\*\*을 사용하여 병합합니다.
  * `main` 브랜치에는 "Merge pull request \#30 from develop" 라는 병합 기록이 남아, 배포 시점을 명확히 추적할 수 있습니다.

### **3단계: 릴리즈 태그 생성 및 푸시**

`main` 브랜치에 배포가 완료되면, 해당 시점에 태그를 생성하여 버전을 기록합니다.

```bash
# 1. main 브랜치로 이동 및 최신화
git checkout main
git pull origin main

# 2. v1.0.0 같은 시맨틱 버저닝 태그 생성
git tag -a v1.0.0 -m "Release v1.0.0: DM 기능 추가"

# 3. 원격 저장소에 태그 푸시
git push origin v1.0.0
```

-----

## 5. 커밋 및 병합 전략 요약

### **커밋 메시지 컨벤션**

이 전략은 **두 종류의 커밋 메시지**를 가집니다.

1.  **작업 커밋 (Feature 브랜치)**

      * `feature` 브랜치에서 작업하며 남기는 커밋입니다.
      * 어차피 Squash될 것이므로, 이슈 번호 없이 `Fix: 오타 수정`처럼 자유롭게 작성합니다.

2.  **최종 커밋 (Squash and Merge 시)**

      * PR이 `develop`으로 병합될 때 사용되는 **단 하나의 커밋**입니다.
      * **규칙:** `태그: #이슈번호 내용`
      * **태그 종류:**
          * `Feat`: 새로운 기능 추가
          * `Fix`: 버그 수정
          * `Docs`: 문서 수정
          * `Style`: 코드 스타일 수정 (포맷팅 등)
          * `Refactor`: 코드 리팩토링
          * `Test`: 테스트 코드 추가/수정
          * `Chore`: 빌드 작업, 패키지 매니저 설정 등
      * **예시:** `Feat: #25 DM 기능 구현 (Closes #25)`

### **병합(Merge) 전략**

1.  **`feature` → `develop` : Squash and Merge (스쿼시 앤 머지)**

      * **이유:** `develop` 브랜치의 히스토리를 이슈 단위의 깔끔한 기능 목록으로 유지하기 위함.

2.  **`develop` → `main` : Merge Commit (일반 머지)**

      * **이유:** 배포 시점에 어떤 기능들이 포함되었는지 `develop`의 모든 커밋 내역을 보존하고, 배포 시점을 명확히 기록하기 위함.

-----

## 6. 핵심 규칙 요약

1.  모든 작업은 **GitHub Issue** 생성에서 시작합니다.
2.  **절대** `main`이나 `develop`에 직접 커밋하지 마세요.
3.  모든 작업은 `develop`에서 분기한 `feature` 브랜치에서 수행하세요.
4.  `feature` 브랜치는 \*\*Pull Request (PR)\*\*를 통해 `develop`으로 **Squash and Merge** 하세요.
5.  `feature`의 **작업 커밋**은 자유롭게, PR **병합 커밋**은 `태그: #이슈번호 내용` 컨벤션을 따르세요.
6.  배포(릴리즈)는 `develop`을 `main`으로 **PR을 통해 Merge Commit** 함으로써 수행하세요.
7.  배포 완료 후 `main` 브랜치에 **Tag**를 생성하여 버전을 기록하세요.